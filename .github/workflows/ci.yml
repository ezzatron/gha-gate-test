name: CI

on:
  push:
  pull_request:

concurrency:
  group: ci-${{ github.event_name == 'pull_request' && github.head_ref || github.ref }}
  cancel-in-progress: false

jobs:
  dev:
    name: Development
    runs-on: ubuntu-latest

    environment:
      name: Development

    steps:
      - name: Sleep for 10 seconds
        run: sleep 10

      - name: Debug
        run: |
          echo "Event name: ${{ github.event_name }}"
          echo "Ref: ${{ github.ref }}"
          echo "Base ref: ${{ github.base_ref }}"

  check-default-branch:
    name: Check default branch lock
    runs-on: ubuntu-latest
    needs: [dev]
    # Despite being called "base_ref", this is actually just a branch name
    if: github.event_name == 'pull_request' && github.base_ref == 'main'

    permissions:
      statuses: write

    steps:
      - name: Create PR status
        uses: actions/github-script@v8
        env:
          HEAD_SHA: ${{ github.event.pull_request.head.sha }}
        with:
          script: |
            // Look up the latest commit on main
            const mainBranch = await github.rest.repos.getBranch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              branch: 'main',
            });
            const mainSha = mainBranch.data.commit.sha;
            console.log(`Latest commit on main is ${mainSha}`);

            // Check if the latest commit on main has a successful deployment to
            // Production. The easiest way to do this is to paginate through the
            // check runs, as they also have deployment info when the check run
            // is from a deployment.
            let isDeployed = false;
            const checkRunPages = github.paginate.iterator(github.rest.checks.listForRef, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: mainSha,
            });
            outer: for await (const { data: checkRunPage } of checkRunPages) {
              console.log(`Processing ${checkRunPage.length} check runs...`);
              for (const checkRun of checkRunPage) {
                if (checkRun.conclusion === 'success' && checkRun.deployment?.environment === 'Production') {
                  isDeployed = true;
                  break outer;
                }
              }
            }

            if (isDeployed) {
              console.log(`Found successful Production deployment`);
            } else {
              console.log(`No successful Production deployment found`);
            }

            // Set the PR status accordingly
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: process.env.HEAD_SHA,
              state: isDeployed ? "success" : "pending",
              context: "Default branch deployment",
              description: isDeployed ? "Ready for merge" : "Un-deployed changes"
            });

  lock-default-branch:
    name: Lock default branch
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    permissions:
      statuses: write

    steps:
      - name: Create PR statuses
        uses: actions/github-script@v8
        with:
          script: |
            console.log('Locking default branch - setting PRs to pending...');
            // Find all open PRs targeting main
            const prPages = github.paginate.iterator(github.rest.pulls.list, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              base: 'main',
            });

            // Create a commit status for each PR
            for await (const { data: prPage } of prPages) {
              console.log(`Processing ${prPage.length} PR(s)...`);
              for (const pr of prPage) {
                console.log(`Updating PR #${pr.number} status to pending`);
                await github.rest.repos.createCommitStatus({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  sha: pr.head.sha,
                  state: "pending",
                  context: "Default branch deployment",
                  description: "Un-deployed changes"
                });
              }
            }

  stg:
    name: Staging
    runs-on: ubuntu-latest
    needs: [dev, lock-default-branch] # Since this needs lock, it will only run on pushes to default branch

    environment:
      name: Staging

    steps:
      - name: Sleep for 5 seconds
        run: sleep 5

  prd:
    name: Production
    runs-on: ubuntu-latest
    needs: [stg]

    environment:
      name: Production

    steps:
      - name: Sleep for 5 seconds
        run: sleep 5

      - name: Fail or succeed based on commit message
        run: |
          if [[ "${{ github.event.head_commit.message }}" != "succeed" ]]; then
            exit 1
          fi

  unlock-default-branch:
    name: Unlock default branch
    runs-on: ubuntu-latest
    needs: [prd]

    permissions:
      statuses: write

    steps:
      - name: Create PR statuses
        uses: actions/github-script@v8
        with:
          script: |
            console.log('Unlocking default branch - setting PRs to success...');
            // Find all open PRs targeting main
            const prPages = github.paginate.iterator(github.rest.pulls.list, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              base: 'main',
            });

            // Create a commit status for each PR
            for await (const { data: prPage } of prPages) {
              console.log(`Processing ${prPage.length} PR(s)...`);
              for (const pr of prPage) {
                console.log(`Updating PR #${pr.number} status to success`);
                await github.rest.repos.createCommitStatus({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  sha: pr.head.sha,
                  state: "success",
                  context: "Default branch deployment",
                  description: "Ready for merge"
                });
              }
            }
